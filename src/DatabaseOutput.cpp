/*************************************************
 ** \file DatabaseOutput.cpp
 ** Class to output information with sqlite3
 **   databases.
 ** Written: S.V. Paulauskas - 30 Aug 2011
 ************************************************/
#include <algorithm>
#include <iostream>
#include <sstream>

#include <cstdlib>
#include <cmath>

#include "DatabaseOutput.hpp"

using namespace std;

//********** BuildCommand **********
vector<string> DatabaseOutput::BuildCommand(void)
{
   vector<string> temp;
   stringstream command;

   if(table_ == "eff") {
      temp.push_back("select * from eff");
      return(temp);
   }

   switch(gammas_.size()) {
   case 0:
      cout << "The vector containing the gammas for search is empty."
	   << "  This is a big problem.  Exiting... " << endl;
      exit(1);
      break;
   case 1:
      command << "select * from " << table_ << " where Gamma="
	      << gammas_.at(0);
      break;
   case 2:
      if(table_ == "range")
	 command << "select Gamma from generalInfo where Gamma>="
		 << gammas_.at(0) << " and Gamma<=" << gammas_.at(1);
      else
	 command << "select * from " << table_ << " where Gamma>="
		 << gammas_.at(0) << " and Gamma<=" << gammas_.at(1);
      break;
   default:
      cout << "Problems constructing the sql command for output." << endl;
      exit(1);
      break;
   }
   temp.push_back(command.str());
   return (temp);
}


//********** CoinCompairson **********
bool CoinCompairson(const pair<string, string> &alpha,
		    const pair<string, string> &beta)
{
   if(atoi(alpha.second.c_str()) < atoi(beta.second.c_str()))
      return(true);
   else
      return(false);
}


//********** EfficiencyCalc **********
double DatabaseOutput::EfficiencyCalc(const double &energy)
{
   double a = atof(efficiency_.at(1).second.c_str());
   double b = atof(efficiency_.at(4).second.c_str());
   double c = atof(efficiency_.at(7).second.c_str());
   double d = atof(efficiency_.at(10).second.c_str());
   double e = atof(efficiency_.at(13).second.c_str());
   double f = atof(efficiency_.at(16).second.c_str());
   double g = atof(efficiency_.at(19).second.c_str());
   double E1 = 50.;
   double E2 = 1000.;

   double eff = exp(pow(pow((a+b*log10(energy/E1)+c*pow(log10(energy/E1),2)),-g) +
    			pow(d+e*log10(energy/E2)+f*pow(log10(energy/E2),2), -g), -1/g));
   return(eff);
}


//********** OutputHeading **********
void DatabaseOutput::OutputHeading(void)
{
   if(table_ == "generalInfo"){
      cout << endl << "General Information" << endl
	   << "---------------------------" << endl;
   }else if(table_ == "coinInfo"){
      cout << endl << "Coincidence Information" << endl
	   << "---------------------------" << endl;
   }else if(table_ == "fitInfo") {
      cout << endl << "Fit Information" << endl
	   << "---------------------------" << endl;
   }else if(table_ == "range") {
      cout << endl << "Gammas found in this range: ";
   }
}


//********** OutputData **********
void DatabaseOutput::OutputData(void)
{
   double gammaEnergy = 0, efficiency = 0, temp = 0;
   string label = "", value = "";

   if(table_ == "coincidences") {
      sort(data_->begin(), data_->end(), CoinCompairson);
      cout << "These gammas are in coincidence: ";
      for(vector<pair<string,string> >::iterator it = data_->begin();
	  it != data_->end(); it++) {
	 if((*it).first == "CoinGamma")
	    cout << (*it).second << ", ";
      }
      cout << endl;
   }else {
      for(vector<pair<string,string> >::iterator it = data_->begin();
	  it != data_->end(); it++){
	 label = (*it).first;
	 value = (*it).second;

	 if(table_ == "range" && label == "Gamma")  {
	    cout << value << ", ";
	    continue;
	 }

	 if(label == "Centroid") {
	    gammaEnergy = atof(value.c_str());
	    cout << label << " = " << value << endl;
	 }else if(label == "Area") {
	    efficiency = EfficiencyCalc(gammaEnergy) / 100;
	    temp = atof(value.c_str()) * efficiency;
	    it++;
	    cout << "Intensity = " << temp << " +- "
		 << temp * (atof((*it).second.c_str())/100) << endl;
	 } else if(label == "HalfLife") {
	    it++;
	    cout << label << " = " << value << " +- "
		 << atof(value.c_str()) * (atof((*it).second.c_str())/100)
		 << endl;
	 } else {
	    cout << label << " = " << value << endl;
	 }
      }
      cout << endl;
   }
}


//********** OutputHelpInfo **********
void DatabaseOutput::OutputHelpInfo(void)
{
   cout << endl << "A program to help organize gammas." << endl
	<< "Example: ./gammaSearch <database name> <flag> <gammaEnergy>" << endl
	<< "Recognized flags (place before the energy): " << endl
	<< "-h -> displays this message" << endl
	<< "-g -> outputs general information (default)" << endl
	<< "-c -> outputs general + coincidence information" << endl
	<< "-f -> outputs general + fit information" << endl
	<< "-v -> outputs all information" << endl
	<< "To search in an energy range simply enter the "
	<< "low (>0) and high bound." << endl
	<< "General output for a range can be generated by passing"
	<< " the \"-g\" flag." << endl
	<< "Problems? Contact stanpaulauskas@gmail.com" << endl << endl;
}


//********** ParseData **********
void DatabaseOutput::ParseData(const vector<string> &tables,
			       const vector<string> &gammas)
{
   gammas_ = gammas;

   table_ = "eff";
   interface.QueryDatabase(BuildCommand());
   data_ = interface.GetRequestedData();
   for(unsigned int i = 0; i < data_->size(); i++)
      efficiency_.push_back(data_->at(i));

   for(unsigned int i = 0; i < tables.size(); i++) {
      table_ = tables[i];
      interface.QueryDatabase(BuildCommand());
      data_ = interface.GetRequestedData();
      OutputHeading();
      OutputData();
      data_->clear();
   }
}
